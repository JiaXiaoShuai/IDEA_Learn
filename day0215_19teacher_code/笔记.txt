/**
 * 3.泛型可以在哪里声明
 *（1）在类或者接口名后面声明，这样的类和接口被称为泛型类和泛型接口，或者是参数化的类型
 *      public interface Comparable<T>{
 *          public int compareTo(T o);//这个不是泛型方法
 *      }
 * (2)在方法的返回值类型前面，这样的方法成为泛型方法。
 * java.util.Arrays类:
 *      public static <T> List<T> asList(T... a){
 *          return new ArrayList<>(a);
 *      }
 */


 /**
  * 泛型generic
  * 说明：泛型本身并一定是非要在集合中使用，很多非集合的场景也是要使用泛型的
  * 因为我们目前SE阶段的API，大量的泛型的使用都在集合API中，所以这个章节的案例以集合演示比较多
  * <p>
  * 一、泛型的引入
  * 什么是泛型
  * 泛型，有点像瓶子上的“标签”，可以再使用之前，表明某个xx的类型是啥，用的时候既方便又安全
  * 对于java程序中：
  * （1）可以把类型检查提到“编译时”
  * （2）使用时，类型是安全的，不需要再强制类型转换
  * <p>
  * 泛型如何设计的？或者说如何传递类型的？
  * 用之前的知识来辅助理解他
  * 之前学习方法的时候，我们有形参和实参的概念
  * 为什么方法有形参？因为方法体的功能实现，需要外界（使用者）给他提供数据，这个数据在编写方法体时
  * 数值是不确定的，需要再调用方法时，才能确定
  * 例如：编写一个方法，可以求两个整数的和。
  * public static int add(int a, int b){
  * return a + b;
  * }
  * <p>
  * 现在设计某个类时，出现了某个成员的类型未知，需要在使用这个类的时候才能确定，就可以把这个类型作为参数传递
  * 写在类后面
  * <p>
  * public class ArrayList<E>{//E就是代表未知的类型，又称为类型形参
  * public void add（E e）{//添加一个元素到集合中
  * //.......
  * }
  * }
  * <p>
  * ArrayList<String> list = new ArrayList<String>();
  * <E>对应<String>
  * 总结：泛型就是参数化类型，即泛型就是传递类型用的一种语法
  * <p>
  * 2.相关名词
  * ArrayList<E>,其中的E是类型变量，因为E是一种未知的类型，可能代表String，可能代表Integer等
  * 可以变，所以称为变量类型
  *
  * <E>:称为类型参数
  * ArrayList<E>:称为参数化类型
  */

  /**
   * 3.自定义泛型类
   * 当我们在类或接口中定义某个成员时，该成员的相关类型是不确定的，而这个类型需要在使用这个类或者接口
   * 时才会确定，那么我们可以使用泛型
   *
   * 【修饰符】 class 类名 <类型变量列表> 【extends 父类】 【implements 父接口们】(接口可以多继承接口)
   *
   * 【修饰符】 interface 接口名 <类型变量列表> 【extends 父接口们】
   *
   * 注意：
   *  （1）自己声明类型变量时，请用单个大写字母表示未知的泛型类型
   *  通常：<T><R><E><U>等
   *  （2）如果有多个未知的类型需要传递，那么类型变量可以同时声明多个，每一个使用逗号分隔
   *  例如：<K,V>
   *
   *      这里为什么不使用单词，而使用单个的大写字母呢？
   * 因为如果写单词，会和已知的类型混淆，重名，无法区别。
   *
   * 例如：我们要声明一个学生类，该学生包含姓名、成绩，而此时学生的成绩类型不确定，为什么呢，
   * 因为，语文老师希望成绩是“优秀”、“良好”、“及格”、“不及格”，
   * 数学老师希望成绩是89.5, 65.0，
   * 英语老师希望成绩是'A','B','C','D','E'。
   * 那么我们在设计这个学生类时，就可以使用泛型。
   *
   * (3)泛型类或泛型接口中，就可以使用类或接口上面的声明的泛型，用它声明变量，参数，返回值类型等
   * （4）但是类或接口上面声明的泛型不允许用在静态成员上。
   *    为什么？
   *    因为类或接口上面声明的泛型是未知的类型，需要再new对象时确定，而静态是早于对象创建的使用，或者说不依赖与对象的。
   */

    /*
    3、独立声明两个泛型方法，和两个使用了泛型类或泛型接口上面的泛型变量的区别
    */

    /**
     * 三、泛型方法
     * 1、在java.util.Arrays工具类中，就有这样一些泛型方法：
     * （1）public static <T> List<T> asList(T... a):这个T类型代表未知的形参类型
     * 即在设计这个方法时，无法确定形参的类型。形参是要添加到List集合中的元素。
     *
     * （2） public static <T> T[] copyOf(T[] original ,int newLength):复制一个新的数组
     * 这里新的数组的类型不确定，原数组的类型也不确定。用T来表示
     */

