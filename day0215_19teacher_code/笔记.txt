/**
 * 3.泛型可以在哪里声明
 *（1）在类或者接口名后面声明，这样的类和接口被称为泛型类和泛型接口，或者是参数化的类型
 *      public interface Comparable<T>{
 *          public int compareTo(T o);//这个不是泛型方法
 *      }
 * (2)在方法的返回值类型前面，这样的方法成为泛型方法。
 * java.util.Arrays类:
 *      public static <T> List<T> asList(T... a){
 *          return new ArrayList<>(a);
 *      }
 */


 /**
  * 泛型generic
  * 说明：泛型本身并一定是非要在集合中使用，很多非集合的场景也是要使用泛型的
  * 因为我们目前SE阶段的API，大量的泛型的使用都在集合API中，所以这个章节的案例以集合演示比较多
  * <p>
  * 一、泛型的引入
  * 什么是泛型
  * 泛型，有点像瓶子上的“标签”，可以再使用之前，表明某个xx的类型是啥，用的时候既方便又安全
  * 对于java程序中：
  * （1）可以把类型检查提到“编译时”
  * （2）使用时，类型是安全的，不需要再强制类型转换
  * <p>
  * 泛型如何设计的？或者说如何传递类型的？
  * 用之前的知识来辅助理解他
  * 之前学习方法的时候，我们有形参和实参的概念
  * 为什么方法有形参？因为方法体的功能实现，需要外界（使用者）给他提供数据，这个数据在编写方法体时
  * 数值是不确定的，需要再调用方法时，才能确定
  * 例如：编写一个方法，可以求两个整数的和。
  * public static int add(int a, int b){
  * return a + b;
  * }
  * <p>
  * 现在设计某个类时，出现了某个成员的类型未知，需要在使用这个类的时候才能确定，就可以把这个类型作为参数传递
  * 写在类后面
  * <p>
  * public class ArrayList<E>{//E就是代表未知的类型，又称为类型形参
  * public void add（E e）{//添加一个元素到集合中
  * //.......
  * }
  * }
  * <p>
  * ArrayList<String> list = new ArrayList<String>();
  * <E>对应<String>
  * 总结：泛型就是参数化类型，即泛型就是传递类型用的一种语法
  * <p>
  * 2.相关名词
  * ArrayList<E>,其中的E是类型变量，因为E是一种未知的类型，可能代表String，可能代表Integer等
  * 可以变，所以称为变量类型
  *
  * <E>:称为类型参数
  * ArrayList<E>:称为参数化类型
  */

  /**
   * 3.自定义泛型类
   * 当我们在类或接口中定义某个成员时，该成员的相关类型是不确定的，而这个类型需要在使用这个类或者接口
   * 时才会确定，那么我们可以使用泛型
   *
   * 【修饰符】 class 类名 <类型变量列表> 【extends 父类】 【implements 父接口们】(接口可以多继承接口)
   *
   * 【修饰符】 interface 接口名 <类型变量列表> 【extends 父接口们】
   *
   * 注意：
   *  （1）自己声明类型变量时，请用单个大写字母表示未知的泛型类型
   *  通常：<T><R><E><U>等
   *  （2）如果有多个未知的类型需要传递，那么类型变量可以同时声明多个，每一个使用逗号分隔
   *  例如：<K,V>
   *
   *      这里为什么不使用单词，而使用单个的大写字母呢？
   * 因为如果写单词，会和已知的类型混淆，重名，无法区别。
   *
   * 例如：我们要声明一个学生类，该学生包含姓名、成绩，而此时学生的成绩类型不确定，为什么呢，
   * 因为，语文老师希望成绩是“优秀”、“良好”、“及格”、“不及格”，
   * 数学老师希望成绩是89.5, 65.0，
   * 英语老师希望成绩是'A','B','C','D','E'。
   * 那么我们在设计这个学生类时，就可以使用泛型。
   *
   * (3)泛型类或泛型接口中，就可以使用类或接口上面的声明的泛型，用它声明变量，参数，返回值类型等
   * （4）但是类或接口上面声明的泛型不允许用在静态成员上。
   *    为什么？
   *    因为类或接口上面声明的泛型是未知的类型，需要再new对象时确定，而静态是早于对象创建的使用，或者说不依赖与对象的。
   */

    /*
    3、独立声明两个泛型方法，和两个使用了泛型类或泛型接口上面的泛型变量的区别
    */

    /**
     * 三、泛型方法
     * 1、在java.util.Arrays工具类中，就有这样一些泛型方法：
     * （1）public static <T> List<T> asList(T... a):这个T类型代表未知的形参类型
     * 即在设计这个方法时，无法确定形参的类型。形参是要添加到List集合中的元素。
     *
     * （2） public static <T> T[] copyOf(T[] original ,int newLength):复制一个新的数组
     * 这里新的数组的类型不确定，原数组的类型也不确定。用T来表示
     */

/**
 * 2.自定义泛型方法
 * 当有如下情况时，需要声明泛型方法
 * （1）如果我们定义类、接口时没有使用<类型变量>，但是某个方法形参类型不确定时，这个方法可以单独定义<类型变量>
 *  （2）如果我们之前说类和接口上的类型参数是不能用于静态方法中，那么当某个静态方法的形参类型不确定时静态方法可以单独定义<类型变量>
 *
 *   语法格式：
 *   【修饰符】  <泛型类型变量列表>  返回值类型 方法名（【形参列表】） 【throw  异常列表】{}
 *
 *   需求：
 * 我们编写一个数组工具类，包含可以给任意对象数组进行从小到大排序，调用元素对象的compareTo方法比较元素的大小关系。
 */

 /**
  * 四.声明泛型变量时指定上限
  * 我们在声明<T>等类型变量时，可以给它设定“上限”
  * 语法格式：
  *  <T extends 上限>：表示T的类型必须是<= 上限，即要么是上限本身，要么是继承上限类或者实现了上限接口的类型
  *
  *  一个类型变量的上限可以是1个，也可以是很多个，但是要求如果有多个的话，类只能有一个，其他的是接口类型
  *  而且类在左边，其它的类型在右边
  */

  /**
   * 五.泛型擦除
   * 如果用户在使用泛型类型或泛型接口时，没有主动指定泛型的类型，就会发生泛型擦除。
   * 泛型擦除后，类型变量按照哪个类型处理？是统一按照Object处理吗？
   * 不是
   * 答案：泛型擦除后，自动按照类型变量声明时的第一个上限处理，如果类型变量没有指定上限，那么按照Object处理
   */

   /*
   <?>的容器，是无法添加任意元素。可以删除元素
   <? extends 上限>的容器，是无法添加任意元素。可以删除元素
   <? super 下限>的容器，是允许添加元素，但是元素类型有限制，必须是下限或下限子类对象。可以删除元素
    */

    int a = Collator.getInstance(Locale.CHINA).compare(o1.getName(),o2.getName());按照中文比较